"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/source/decompile/route";
exports.ids = ["app/api/source/decompile/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fsource%2Fdecompile%2Froute&page=%2Fapi%2Fsource%2Fdecompile%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsource%2Fdecompile%2Froute.ts&appDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fsource%2Fdecompile%2Froute&page=%2Fapi%2Fsource%2Fdecompile%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsource%2Fdecompile%2Froute.ts&appDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _home_bond_github_bond_auto_sui_skill_web_app_api_source_decompile_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/source/decompile/route.ts */ \"(rsc)/./app/api/source/decompile/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/source/decompile/route\",\n        pathname: \"/api/source/decompile\",\n        filename: \"route\",\n        bundlePath: \"app/api/source/decompile/route\"\n    },\n    resolvedPagePath: \"/home/bond/github/bond/auto-sui-skill/web/app/api/source/decompile/route.ts\",\n    nextConfigOutput,\n    userland: _home_bond_github_bond_auto_sui_skill_web_app_api_source_decompile_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/source/decompile/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxNC4yLjM1X3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyLmpzP25hbWU9YXBwJTJGYXBpJTJGc291cmNlJTJGZGVjb21waWxlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZzb3VyY2UlMkZkZWNvbXBpbGUlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZzb3VyY2UlMkZkZWNvbXBpbGUlMkZyb3V0ZS50cyZhcHBEaXI9JTJGaG9tZSUyRmJvbmQlMkZnaXRodWIlMkZib25kJTJGYXV0by1zdWktc2tpbGwlMkZ3ZWIlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRmhvbWUlMkZib25kJTJGZ2l0aHViJTJGYm9uZCUyRmF1dG8tc3VpLXNraWxsJTJGd2ViJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUMyQjtBQUN4RztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tc3VpLXNraWxscy13ZWIvP2M0YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL2hvbWUvYm9uZC9naXRodWIvYm9uZC9hdXRvLXN1aS1za2lsbC93ZWIvYXBwL2FwaS9zb3VyY2UvZGVjb21waWxlL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9zb3VyY2UvZGVjb21waWxlL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvc291cmNlL2RlY29tcGlsZVwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvc291cmNlL2RlY29tcGlsZS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9ob21lL2JvbmQvZ2l0aHViL2JvbmQvYXV0by1zdWktc2tpbGwvd2ViL2FwcC9hcGkvc291cmNlL2RlY29tcGlsZS9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvc291cmNlL2RlY29tcGlsZS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fsource%2Fdecompile%2Froute&page=%2Fapi%2Fsource%2Fdecompile%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsource%2Fdecompile%2Froute.ts&appDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/source/decompile/route.ts":
/*!*******************************************!*\
  !*** ./app/api/source/decompile/route.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_decompiler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/decompiler */ \"(rsc)/./lib/decompiler.ts\");\n\n\nasync function POST(request) {\n    try {\n        const body = await request.json();\n        const { modules } = body;\n        if (!modules || typeof modules !== \"object\") {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid modules data\"\n            }, {\n                status: 400\n            });\n        }\n        // Decompile each module\n        const decompiled = {};\n        const errors = {};\n        for (const [moduleName, bytecode] of Object.entries(modules)){\n            try {\n                decompiled[moduleName] = (0,_lib_decompiler__WEBPACK_IMPORTED_MODULE_1__.decompileToMove)(bytecode);\n            } catch (error) {\n                errors[moduleName] = error instanceof Error ? error.message : \"Decompilation failed\";\n                // Fallback to original bytecode with annotation\n                decompiled[moduleName] = `// Decompilation failed for ${moduleName}\\n// Original bytecode:\\n\\n${bytecode}`;\n            }\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            decompiled,\n            errors: Object.keys(errors).length > 0 ? errors : undefined,\n            decompileAt: new Date().toISOString()\n        });\n    } catch (error) {\n        console.error(\"Decompile error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error instanceof Error ? error.message : \"Failed to decompile\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL3NvdXJjZS9kZWNvbXBpbGUvcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdEO0FBQ0w7QUFFNUMsZUFBZUUsS0FBS0MsT0FBb0I7SUFDN0MsSUFBSTtRQUNGLE1BQU1DLE9BQU8sTUFBTUQsUUFBUUUsSUFBSTtRQUMvQixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtRQUVwQixJQUFJLENBQUNFLFdBQVcsT0FBT0EsWUFBWSxVQUFVO1lBQzNDLE9BQU9OLHFEQUFZQSxDQUFDSyxJQUFJLENBQ3RCO2dCQUFFRSxPQUFPO1lBQXVCLEdBQ2hDO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSx3QkFBd0I7UUFDeEIsTUFBTUMsYUFBcUMsQ0FBQztRQUM1QyxNQUFNQyxTQUFpQyxDQUFDO1FBRXhDLEtBQUssTUFBTSxDQUFDQyxZQUFZQyxTQUFTLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1IsU0FBVTtZQUM1RCxJQUFJO2dCQUNGRyxVQUFVLENBQUNFLFdBQVcsR0FBR1YsZ0VBQWVBLENBQUNXO1lBQzNDLEVBQUUsT0FBT0wsT0FBTztnQkFDZEcsTUFBTSxDQUFDQyxXQUFXLEdBQUdKLGlCQUFpQlEsUUFBUVIsTUFBTVMsT0FBTyxHQUFHO2dCQUM5RCxnREFBZ0Q7Z0JBQ2hEUCxVQUFVLENBQUNFLFdBQVcsR0FBRyxDQUFDLDRCQUE0QixFQUFFQSxXQUFXLDJCQUEyQixFQUFFQyxTQUFTLENBQUM7WUFDNUc7UUFDRjtRQUVBLE9BQU9aLHFEQUFZQSxDQUFDSyxJQUFJLENBQUM7WUFDdkJJO1lBQ0FDLFFBQVFHLE9BQU9JLElBQUksQ0FBQ1AsUUFBUVEsTUFBTSxHQUFHLElBQUlSLFNBQVNTO1lBQ2xEQyxhQUFhLElBQUlDLE9BQU9DLFdBQVc7UUFDckM7SUFDRixFQUFFLE9BQU9mLE9BQU87UUFDZGdCLFFBQVFoQixLQUFLLENBQUMsb0JBQW9CQTtRQUNsQyxPQUFPUCxxREFBWUEsQ0FBQ0ssSUFBSSxDQUN0QjtZQUFFRSxPQUFPQSxpQkFBaUJRLFFBQVFSLE1BQU1TLE9BQU8sR0FBRztRQUFzQixHQUN4RTtZQUFFUixRQUFRO1FBQUk7SUFFbEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tc3VpLXNraWxscy13ZWIvLi9hcHAvYXBpL3NvdXJjZS9kZWNvbXBpbGUvcm91dGUudHM/MmEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgZGVjb21waWxlVG9Nb3ZlIH0gZnJvbSAnQC9saWIvZGVjb21waWxlcic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICAgIGNvbnN0IHsgbW9kdWxlcyB9ID0gYm9keTtcblxuICAgIGlmICghbW9kdWxlcyB8fCB0eXBlb2YgbW9kdWxlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgbW9kdWxlcyBkYXRhJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGVjb21waWxlIGVhY2ggbW9kdWxlXG4gICAgY29uc3QgZGVjb21waWxlZDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGNvbnN0IGVycm9yczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBbbW9kdWxlTmFtZSwgYnl0ZWNvZGVdIG9mIE9iamVjdC5lbnRyaWVzKG1vZHVsZXMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWNvbXBpbGVkW21vZHVsZU5hbWVdID0gZGVjb21waWxlVG9Nb3ZlKGJ5dGVjb2RlIGFzIHN0cmluZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvcnNbbW9kdWxlTmFtZV0gPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdEZWNvbXBpbGF0aW9uIGZhaWxlZCc7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIG9yaWdpbmFsIGJ5dGVjb2RlIHdpdGggYW5ub3RhdGlvblxuICAgICAgICBkZWNvbXBpbGVkW21vZHVsZU5hbWVdID0gYC8vIERlY29tcGlsYXRpb24gZmFpbGVkIGZvciAke21vZHVsZU5hbWV9XFxuLy8gT3JpZ2luYWwgYnl0ZWNvZGU6XFxuXFxuJHtieXRlY29kZX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBkZWNvbXBpbGVkLFxuICAgICAgZXJyb3JzOiBPYmplY3Qua2V5cyhlcnJvcnMpLmxlbmd0aCA+IDAgPyBlcnJvcnMgOiB1bmRlZmluZWQsXG4gICAgICBkZWNvbXBpbGVBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RlY29tcGlsZSBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGRlY29tcGlsZScgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJkZWNvbXBpbGVUb01vdmUiLCJQT1NUIiwicmVxdWVzdCIsImJvZHkiLCJqc29uIiwibW9kdWxlcyIsImVycm9yIiwic3RhdHVzIiwiZGVjb21waWxlZCIsImVycm9ycyIsIm1vZHVsZU5hbWUiLCJieXRlY29kZSIsIk9iamVjdCIsImVudHJpZXMiLCJFcnJvciIsIm1lc3NhZ2UiLCJrZXlzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZGVjb21waWxlQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb25zb2xlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/source/decompile/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/decompiler.ts":
/*!***************************!*\
  !*** ./lib/decompiler.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decompileBytecode: () => (/* binding */ decompileBytecode),\n/* harmony export */   decompileToMove: () => (/* binding */ decompileToMove),\n/* harmony export */   toMoveSource: () => (/* binding */ toMoveSource)\n/* harmony export */ });\n/**\n * Move Bytecode Decompiler\n * Converts disassembled Move bytecode into readable pseudo-code\n */ /**\n * Decompile Move bytecode into readable pseudo-code\n */ function decompileBytecode(bytecode) {\n    const lines = bytecode.split(\"\\n\");\n    const moduleName = extractModuleName(lines);\n    const structs = extractStructs(lines);\n    const functions = extractAndDecompileFunctions(bytecode);\n    return {\n        moduleName,\n        structs,\n        functions\n    };\n}\n/**\n * Extract module name from bytecode\n */ function extractModuleName(lines) {\n    for (const line of lines){\n        const match = line.match(/^module\\s+[\\w.]+\\.(\\w+)\\s*\\{/);\n        if (match) {\n            return match[1];\n        }\n    }\n    return \"unknown\";\n}\n/**\n * Extract struct definitions\n */ function extractStructs(lines) {\n    const structs = [];\n    let currentStruct = null;\n    let inStruct = false;\n    let braceCount = 0;\n    for (const line of lines){\n        const structMatch = line.match(/^struct\\s+(\\w+)(?:<[^>]+>)?\\s+has\\s+([\\w,\\s]+)\\s*\\{/);\n        if (structMatch) {\n            currentStruct = {\n                name: structMatch[1],\n                abilities: structMatch[2].split(\",\").map((a)=>a.trim()),\n                fields: []\n            };\n            inStruct = true;\n            braceCount = 1;\n            continue;\n        }\n        // Also match structs without abilities\n        const structMatchNoAbilities = line.match(/^struct\\s+(\\w+)(?:<[^>]+>)?\\s*\\{/);\n        if (structMatchNoAbilities && !inStruct) {\n            currentStruct = {\n                name: structMatchNoAbilities[1],\n                abilities: [],\n                fields: []\n            };\n            inStruct = true;\n            braceCount = 1;\n            continue;\n        }\n        if (inStruct && currentStruct) {\n            const fieldMatch = line.match(/^\\s*(\\w+):\\s*(.+?),?\\s*$/);\n            if (fieldMatch) {\n                currentStruct.fields.push({\n                    name: fieldMatch[1],\n                    type: cleanType(fieldMatch[2])\n                });\n            }\n            if (line.includes(\"}\")) {\n                braceCount--;\n                if (braceCount <= 0) {\n                    structs.push(currentStruct);\n                    currentStruct = null;\n                    inStruct = false;\n                }\n            }\n        }\n    }\n    return structs;\n}\n/**\n * Extract and decompile functions\n */ function extractAndDecompileFunctions(bytecode) {\n    const functions = [];\n    // Split by function patterns\n    const funcBlocks = bytecode.split(/\\n(?=(?:public|entry|friend|private)\\s)/);\n    for (const block of funcBlocks){\n        const func = parseFunction(block);\n        if (func) {\n            functions.push(func);\n        }\n    }\n    return functions;\n}\n/**\n * Parse a single function block\n */ function parseFunction(block) {\n    const lines = block.split(\"\\n\");\n    const firstLine = lines[0];\n    // Match function signature\n    const sigMatch = firstLine.match(/^(public(?:\\s+entry)?|entry|friend|private)?\\s*(\\w+)(?:<([^>]+)>)?\\(([^)]*)\\)(?:\\s*:\\s*([^\\{]+))?/);\n    if (!sigMatch) return null;\n    const visibility = sigMatch[1] || \"private\";\n    const name = sigMatch[2];\n    const typeParamsStr = sigMatch[3] || \"\";\n    const paramsStr = sigMatch[4] || \"\";\n    const returnType = sigMatch[5]?.trim() || \"void\";\n    // Skip if it looks like a struct or module definition\n    if ([\n        \"module\",\n        \"struct\",\n        \"use\",\n        \"const\"\n    ].includes(name)) return null;\n    // Parse type parameters\n    const typeParams = typeParamsStr ? typeParamsStr.split(\",\").map((t)=>t.trim()) : [];\n    // Parse parameters\n    const params = parseParams(paramsStr);\n    // Extract and decompile body\n    const bodyLines = lines.slice(1);\n    const originalBytecode = bodyLines.join(\"\\n\");\n    const body = decompileFunctionBody(bodyLines, params, name);\n    return {\n        name,\n        visibility,\n        typeParams,\n        params,\n        returnType: cleanType(returnType),\n        body,\n        originalBytecode\n    };\n}\n/**\n * Parse function parameters\n */ function parseParams(paramsStr) {\n    if (!paramsStr.trim()) return [];\n    const params = [];\n    // Handle nested generics properly\n    let depth = 0;\n    let current = \"\";\n    for (const char of paramsStr){\n        if (char === \"<\") depth++;\n        if (char === \">\") depth--;\n        if (char === \",\" && depth === 0) {\n            const match = current.match(/(\\w+):\\s*(.+)/);\n            if (match) {\n                params.push({\n                    name: match[1],\n                    type: cleanType(match[2])\n                });\n            }\n            current = \"\";\n        } else {\n            current += char;\n        }\n    }\n    // Handle last parameter\n    if (current.trim()) {\n        const match = current.match(/(\\w+):\\s*(.+)/);\n        if (match) {\n            params.push({\n                name: match[1],\n                type: cleanType(match[2])\n            });\n        }\n    }\n    return params;\n}\n/**\n * Decompile function body from bytecode instructions\n */ function decompileFunctionBody(lines, params, funcName) {\n    const statements = [];\n    const locals = new Map();\n    const stack = [];\n    let localCounter = 0;\n    // Initialize params in locals\n    params.forEach((p, i)=>{\n        locals.set(`Arg${i}`, p.name);\n    });\n    // Parse local variable declarations\n    for (const line of lines){\n        const localMatch = line.match(/^L(\\d+):\\s*loc\\d+:\\s*(.+)$/);\n        if (localMatch) {\n            const varName = generateVarName(localMatch[2], localCounter++);\n            locals.set(`L${localMatch[1]}`, varName);\n        }\n    }\n    // Process bytecode instructions\n    for (const line of lines){\n        const trimmed = line.trim();\n        if (!trimmed || trimmed.startsWith(\"L\") || trimmed.startsWith(\"B\")) continue;\n        const instrMatch = trimmed.match(/^\\d+:\\s*(\\w+)(?:\\[([^\\]]*)\\])?(?:\\(([^)]*)\\))?$/);\n        if (!instrMatch) continue;\n        const [, opcode, operand, annotation] = instrMatch;\n        processInstruction(opcode, operand, annotation, locals, stack, statements);\n    }\n    // Format the body\n    if (statements.length === 0) {\n        return \"    // Complex bytecode - see original for details\";\n    }\n    return statements.map((s)=>`    ${s}`).join(\"\\n\");\n}\n/**\n * Process a single bytecode instruction\n */ function processInstruction(opcode, operand, annotation, locals, stack, statements) {\n    switch(opcode){\n        case \"CopyLoc\":\n        case \"MoveLoc\":\n            {\n                const varName = getLocalName(operand, annotation, locals);\n                stack.push(varName);\n                break;\n            }\n        case \"ImmBorrowLoc\":\n        case \"MutBorrowLoc\":\n            {\n                const varName = getLocalName(operand, annotation, locals);\n                const prefix = opcode === \"MutBorrowLoc\" ? \"&mut \" : \"&\";\n                stack.push(`${prefix}${varName}`);\n                break;\n            }\n        case \"StLoc\":\n            {\n                const value = stack.pop() || \"?\";\n                const varName = getLocalName(operand, annotation, locals);\n                // Avoid duplicate let statements\n                if (!statements.some((s)=>s.startsWith(`let ${varName} =`))) {\n                    statements.push(`let ${varName} = ${value};`);\n                } else {\n                    statements.push(`${varName} = ${value};`);\n                }\n                break;\n            }\n        case \"Call\":\n            {\n                const funcCall = parseCallAnnotation(annotation);\n                if (funcCall) {\n                    const { module, func, returnType, argCount } = funcCall;\n                    const args = [];\n                    for(let i = 0; i < argCount; i++){\n                        args.unshift(stack.pop() || \"?\");\n                    }\n                    const callExpr = `${module}::${func}(${args.join(\", \")})`;\n                    if (returnType && returnType !== \"()\") {\n                        stack.push(callExpr);\n                    } else {\n                        statements.push(`${callExpr};`);\n                    }\n                }\n                break;\n            }\n        case \"Pack\":\n            {\n                const structInfo = parsePackAnnotation(annotation);\n                if (structInfo) {\n                    stack.push(`${structInfo.name} { ... }`);\n                }\n                break;\n            }\n        case \"Unpack\":\n            {\n                const structInfo = parsePackAnnotation(annotation);\n                if (structInfo) {\n                    const value = stack.pop() || \"?\";\n                    statements.push(`let ${structInfo.name} { ... } = ${value};`);\n                }\n                break;\n            }\n        case \"Ret\":\n            {\n                const returnVal = stack.pop();\n                if (returnVal) {\n                    statements.push(`return ${returnVal};`);\n                } else {\n                    statements.push(\"return;\");\n                }\n                break;\n            }\n        case \"FreezeRef\":\n            {\n                const val = stack.pop();\n                if (val?.startsWith(\"&mut \")) {\n                    stack.push(val.replace(\"&mut \", \"&\"));\n                } else {\n                    stack.push(val || \"?\");\n                }\n                break;\n            }\n        case \"LdU8\":\n        case \"LdU16\":\n        case \"LdU32\":\n        case \"LdU64\":\n        case \"LdU128\":\n        case \"LdU256\":\n            {\n                stack.push(operand || \"0\");\n                break;\n            }\n        case \"LdTrue\":\n            stack.push(\"true\");\n            break;\n        case \"LdFalse\":\n            stack.push(\"false\");\n            break;\n        case \"LdConst\":\n            {\n                stack.push(annotation || \"CONST\");\n                break;\n            }\n        case \"Pop\":\n            {\n                const val = stack.pop();\n                if (val && !val.startsWith(\"?\")) {\n                    statements.push(`_ = ${val};`);\n                }\n                break;\n            }\n        case \"BrTrue\":\n        case \"BrFalse\":\n            {\n                const cond = stack.pop();\n                if (cond) {\n                    const keyword = opcode === \"BrTrue\" ? \"if\" : \"if !\";\n                    statements.push(`${keyword}(${cond}) { /* branch */ }`);\n                }\n                break;\n            }\n        case \"Branch\":\n            {\n                statements.push(\"// jump\");\n                break;\n            }\n        case \"Abort\":\n            {\n                const code = stack.pop() || \"?\";\n                statements.push(`abort ${code};`);\n                break;\n            }\n        case \"ImmBorrowField\":\n        case \"MutBorrowField\":\n            {\n                const obj = stack.pop() || \"?\";\n                const fieldName = annotation?.match(/\\.(\\w+)/)?.[1] || \"field\";\n                const prefix = opcode === \"MutBorrowField\" ? \"&mut \" : \"&\";\n                stack.push(`${prefix}${obj}.${fieldName}`);\n                break;\n            }\n        case \"ReadRef\":\n            {\n                const ref = stack.pop() || \"?\";\n                stack.push(`*${ref}`);\n                break;\n            }\n        case \"WriteRef\":\n            {\n                const value = stack.pop() || \"?\";\n                const ref = stack.pop() || \"?\";\n                statements.push(`*${ref} = ${value};`);\n                break;\n            }\n        case \"Add\":\n        case \"Sub\":\n        case \"Mul\":\n        case \"Div\":\n        case \"Mod\":\n            {\n                const b = stack.pop() || \"?\";\n                const a = stack.pop() || \"?\";\n                const op = {\n                    Add: \"+\",\n                    Sub: \"-\",\n                    Mul: \"*\",\n                    Div: \"/\",\n                    Mod: \"%\"\n                }[opcode];\n                stack.push(`(${a} ${op} ${b})`);\n                break;\n            }\n        case \"Lt\":\n        case \"Le\":\n        case \"Gt\":\n        case \"Ge\":\n        case \"Eq\":\n        case \"Neq\":\n            {\n                const b = stack.pop() || \"?\";\n                const a = stack.pop() || \"?\";\n                const op = {\n                    Lt: \"<\",\n                    Le: \"<=\",\n                    Gt: \">\",\n                    Ge: \">=\",\n                    Eq: \"==\",\n                    Neq: \"!=\"\n                }[opcode];\n                stack.push(`(${a} ${op} ${b})`);\n                break;\n            }\n        case \"And\":\n            {\n                const b = stack.pop() || \"?\";\n                const a = stack.pop() || \"?\";\n                stack.push(`(${a} && ${b})`);\n                break;\n            }\n        case \"Or\":\n            {\n                const b = stack.pop() || \"?\";\n                const a = stack.pop() || \"?\";\n                stack.push(`(${a} || ${b})`);\n                break;\n            }\n        case \"Not\":\n            {\n                const a = stack.pop() || \"?\";\n                stack.push(`!${a}`);\n                break;\n            }\n        case \"CastU8\":\n        case \"CastU16\":\n        case \"CastU32\":\n        case \"CastU64\":\n        case \"CastU128\":\n        case \"CastU256\":\n            {\n                const val = stack.pop() || \"?\";\n                const targetType = opcode.replace(\"Cast\", \"\").toLowerCase();\n                stack.push(`(${val} as ${targetType})`);\n                break;\n            }\n        case \"VecPack\":\n            {\n                const count = parseInt(operand || \"0\", 10);\n                const elements = [];\n                for(let i = 0; i < count; i++){\n                    elements.unshift(stack.pop() || \"?\");\n                }\n                stack.push(`vector[${elements.join(\", \")}]`);\n                break;\n            }\n        case \"VecLen\":\n            {\n                const vec = stack.pop() || \"?\";\n                stack.push(`${vec}.length()`);\n                break;\n            }\n        case \"VecImmBorrow\":\n        case \"VecMutBorrow\":\n            {\n                const idx = stack.pop() || \"?\";\n                const vec = stack.pop() || \"?\";\n                const prefix = opcode === \"VecMutBorrow\" ? \"&mut \" : \"&\";\n                stack.push(`${prefix}${vec}[${idx}]`);\n                break;\n            }\n        case \"VecPushBack\":\n            {\n                const val = stack.pop() || \"?\";\n                const vec = stack.pop() || \"?\";\n                statements.push(`${vec}.push_back(${val});`);\n                break;\n            }\n        case \"VecPopBack\":\n            {\n                const vec = stack.pop() || \"?\";\n                stack.push(`${vec}.pop_back()`);\n                break;\n            }\n        default:\n            break;\n    }\n}\n/**\n * Get local variable name\n */ function getLocalName(operand, annotation, locals) {\n    if (annotation) {\n        // Try to extract from annotation like \"Arg0: &mut TxContext\"\n        const match = annotation.match(/^(\\w+):/);\n        if (match) {\n            const key = match[1];\n            if (locals.has(key)) {\n                return locals.get(key);\n            }\n            // It's a new variable name from annotation\n            return key.toLowerCase();\n        }\n    }\n    if (operand) {\n        return locals.get(operand) || operand.toLowerCase();\n    }\n    return \"var\";\n}\n/**\n * Parse Call annotation to extract function info\n */ function parseCallAnnotation(annotation) {\n    if (!annotation) return null;\n    // Pattern: module::func<TypeArgs>(ArgTypes): ReturnType\n    const match = annotation.match(/(\\w+)::(\\w+)(?:<[^>]+>)?\\(([^)]*)\\)(?::\\s*(.+))?/);\n    if (!match) return null;\n    const argTypes = match[3] ? match[3].split(\",\").filter((a)=>a.trim()) : [];\n    return {\n        module: match[1],\n        func: match[2],\n        returnType: match[4]?.trim() || \"\",\n        argCount: argTypes.length\n    };\n}\n/**\n * Parse Pack annotation\n */ function parsePackAnnotation(annotation) {\n    if (!annotation) return null;\n    const match = annotation.match(/(\\w+)(?:<|$)/);\n    return match ? {\n        name: match[1]\n    } : null;\n}\n/**\n * Generate variable name from type with enhanced inference\n */ function generateVarName(type, index, context) {\n    const cleanedType = type.replace(/<.*>/, \"\").trim();\n    const parts = cleanedType.split(\"::\");\n    const typeName = parts[parts.length - 1];\n    // Extract generic type parameter if present\n    const genericMatch = type.match(/<([^<>]+)>/);\n    const genericType = genericMatch ? genericMatch[1].split(\"::\").pop() : null;\n    // Enhanced name mapping with semantic context\n    const nameMap = {\n        // Object types\n        \"UID\": \"uid\",\n        \"ID\": \"id\",\n        \"Bag\": \"bag\",\n        \"Table\": \"table\",\n        \"VecSet\": \"vec_set\",\n        \"VecMap\": \"vec_map\",\n        \"ObjectBag\": \"object_bag\",\n        \"ObjectTable\": \"object_table\",\n        \"LinkedTable\": \"linked_table\",\n        // Token types\n        \"Coin\": genericType ? `${genericType.toLowerCase()}_coin` : \"coin\",\n        \"Balance\": genericType ? `${genericType.toLowerCase()}_balance` : \"balance\",\n        \"TreasuryCap\": \"treasury_cap\",\n        \"CoinMetadata\": \"coin_metadata\",\n        \"Supply\": \"supply\",\n        // Common types\n        \"TxContext\": \"ctx\",\n        \"address\": \"recipient\",\n        \"u64\": \"amount\",\n        \"u128\": \"value\",\n        \"u256\": \"big_value\",\n        \"u8\": \"byte_val\",\n        \"u16\": \"short_val\",\n        \"u32\": \"int_val\",\n        \"bool\": \"is_valid\",\n        \"String\": \"name\",\n        \"Url\": \"url\",\n        \"Option\": genericType ? `maybe_${genericType.toLowerCase()}` : \"option\",\n        // Vector types\n        \"vector\": genericType ? `${genericType.toLowerCase()}_list` : \"items\",\n        // Capability types\n        \"AdminCap\": \"admin_cap\",\n        \"OwnerCap\": \"owner_cap\",\n        \"UpgradeCap\": \"upgrade_cap\",\n        \"Publisher\": \"publisher\",\n        // Clock & time\n        \"Clock\": \"clock\",\n        // DeFi common types\n        \"Pool\": \"pool\",\n        \"Position\": \"position\",\n        \"Liquidity\": \"liquidity\",\n        \"Oracle\": \"oracle\",\n        \"PriceInfo\": \"price_info\"\n    };\n    // Context-aware naming based on function name\n    if (context?.funcName) {\n        const funcLower = context.funcName.toLowerCase();\n        // Transfer functions\n        if (funcLower.includes(\"transfer\") && typeName === \"address\") {\n            return index > 0 ? `recipient_${index}` : \"recipient\";\n        }\n        // Deposit/withdraw functions\n        if (funcLower.includes(\"deposit\") || funcLower.includes(\"withdraw\")) {\n            if (typeName === \"u64\") return index > 0 ? `amount_${index}` : \"amount\";\n            if (typeName === \"Coin\") return index > 0 ? `deposit_coin_${index}` : \"deposit_coin\";\n        }\n        // Swap functions\n        if (funcLower.includes(\"swap\")) {\n            if (context.paramIndex === 0 && typeName === \"Coin\") return \"coin_in\";\n            if (context.paramIndex === 1 && typeName === \"Coin\") return \"coin_out\";\n            if (typeName === \"u64\") return index > 0 ? `min_out_${index}` : \"min_amount_out\";\n        }\n        // Mint functions\n        if (funcLower.includes(\"mint\")) {\n            if (typeName === \"u64\") return \"mint_amount\";\n            if (typeName === \"TreasuryCap\") return \"treasury\";\n        }\n        // Burn functions\n        if (funcLower.includes(\"burn\")) {\n            if (typeName === \"Coin\") return \"burn_coin\";\n        }\n    }\n    const baseName = nameMap[typeName] || typeName.toLowerCase().replace(/([A-Z])/g, \"_$1\").toLowerCase().replace(/^_/, \"\");\n    return index > 0 ? `${baseName}_${index}` : baseName;\n}\n/**\n * Clean type string\n */ function cleanType(type) {\n    return type.replace(/\\s+/g, \" \").replace(/^\\s+|\\s+$/g, \"\").replace(/,\\s*/g, \", \").replace(/,\\s*$/, \"\");\n}\n/**\n * Convert decompiled module to Move source code string\n */ function toMoveSource(module) {\n    const lines = [];\n    lines.push(`// Decompiled Move module: ${module.moduleName}`);\n    lines.push(`// Note: Variable names and comments are approximated`);\n    lines.push(\"\");\n    lines.push(`module ${module.moduleName} {`);\n    lines.push(\"\");\n    // Structs\n    for (const struct of module.structs){\n        const abilities = struct.abilities.length > 0 ? ` has ${struct.abilities.join(\", \")}` : \"\";\n        lines.push(`    struct ${struct.name}${abilities} {`);\n        for (const field of struct.fields){\n            lines.push(`        ${field.name}: ${field.type},`);\n        }\n        lines.push(\"    }\");\n        lines.push(\"\");\n    }\n    // Functions\n    for (const func of module.functions){\n        const typeParams = func.typeParams.length > 0 ? `<${func.typeParams.join(\", \")}>` : \"\";\n        const params = func.params.map((p)=>`${p.name}: ${p.type}`).join(\", \");\n        const returnType = func.returnType !== \"void\" ? `: ${func.returnType}` : \"\";\n        lines.push(`    ${func.visibility} fun ${func.name}${typeParams}(${params})${returnType} {`);\n        lines.push(func.body || \"        // ...\");\n        lines.push(\"    }\");\n        lines.push(\"\");\n    }\n    lines.push(\"}\");\n    return lines.join(\"\\n\");\n}\n/**\n * Quick decompile function - main entry point\n */ function decompileToMove(bytecode) {\n    try {\n        const module = decompileBytecode(bytecode);\n        return toMoveSource(module);\n    } catch (error) {\n        // If decompilation fails, return annotated bytecode\n        return annotateByteCode(bytecode);\n    }\n}\n/**\n * Annotate bytecode with comments for better readability\n */ function annotateByteCode(bytecode) {\n    const annotations = {\n        \"CopyLoc\": \"// Copy local variable\",\n        \"MoveLoc\": \"// Move local variable (consume)\",\n        \"StLoc\": \"// Store to local variable\",\n        \"ImmBorrowLoc\": \"// Immutable borrow (&)\",\n        \"MutBorrowLoc\": \"// Mutable borrow (&mut)\",\n        \"ImmBorrowField\": \"// Borrow struct field (&)\",\n        \"MutBorrowField\": \"// Borrow struct field (&mut)\",\n        \"Call\": \"// Function call\",\n        \"Pack\": \"// Create struct instance\",\n        \"Unpack\": \"// Destructure struct\",\n        \"Ret\": \"// Return from function\",\n        \"BrTrue\": \"// Branch if true\",\n        \"BrFalse\": \"// Branch if false\",\n        \"Branch\": \"// Unconditional jump\",\n        \"FreezeRef\": \"// Convert &mut to &\",\n        \"LdU64\": \"// Load u64 constant\",\n        \"LdTrue\": \"// Load true\",\n        \"LdFalse\": \"// Load false\",\n        \"Pop\": \"// Discard top of stack\",\n        \"Abort\": \"// Abort execution\"\n    };\n    const lines = bytecode.split(\"\\n\");\n    const annotated = [];\n    for (const line of lines){\n        annotated.push(line);\n        // Add annotation for instruction lines\n        const instrMatch = line.match(/^\\s*\\d+:\\s*(\\w+)/);\n        if (instrMatch && annotations[instrMatch[1]]) {\n            annotated.push(`        ${annotations[instrMatch[1]]}`);\n        }\n    }\n    return annotated.join(\"\\n\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDVixPQUFPO1FBQ1AsVUFBVTtRQUNWLFdBQVc7UUFDWCxVQUFVO1FBQ1YsYUFBYTtRQUNiLFNBQVM7UUFDVCxVQUFVO1FBQ1YsV0FBVztRQUNYLE9BQU87UUFDUCxTQUFTO0lBQ1g7SUFFQSxNQUFNeEksUUFBUUQsU0FBU0UsS0FBSyxDQUFDO0lBQzdCLE1BQU13SSxZQUFzQixFQUFFO0lBRTlCLEtBQUssTUFBTWpJLFFBQVFSLE1BQU87UUFDeEJ5SSxVQUFVbkgsSUFBSSxDQUFDZDtRQUVmLHVDQUF1QztRQUN2QyxNQUFNd0QsYUFBYXhELEtBQUtDLEtBQUssQ0FBQztRQUM5QixJQUFJdUQsY0FBY3dFLFdBQVcsQ0FBQ3hFLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUM1Q3lFLFVBQVVuSCxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUVrSCxXQUFXLENBQUN4RSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN4RDtJQUNGO0lBRUEsT0FBT3lFLFVBQVU5RixJQUFJLENBQUM7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLXN1aS1za2lsbHMtd2ViLy4vbGliL2RlY29tcGlsZXIudHM/ZmUyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vdmUgQnl0ZWNvZGUgRGVjb21waWxlclxuICogQ29udmVydHMgZGlzYXNzZW1ibGVkIE1vdmUgYnl0ZWNvZGUgaW50byByZWFkYWJsZSBwc2V1ZG8tY29kZVxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVjb21waWxlZEZ1bmN0aW9uIHtcbiAgbmFtZTogc3RyaW5nO1xuICB2aXNpYmlsaXR5OiBzdHJpbmc7XG4gIHR5cGVQYXJhbXM6IHN0cmluZ1tdO1xuICBwYXJhbXM6IHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfVtdO1xuICByZXR1cm5UeXBlOiBzdHJpbmc7XG4gIGJvZHk6IHN0cmluZztcbiAgb3JpZ2luYWxCeXRlY29kZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlY29tcGlsZWRNb2R1bGUge1xuICBtb2R1bGVOYW1lOiBzdHJpbmc7XG4gIHN0cnVjdHM6IERlY29tcGlsZWRTdHJ1Y3RbXTtcbiAgZnVuY3Rpb25zOiBEZWNvbXBpbGVkRnVuY3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWNvbXBpbGVkU3RydWN0IHtcbiAgbmFtZTogc3RyaW5nO1xuICBhYmlsaXRpZXM6IHN0cmluZ1tdO1xuICBmaWVsZHM6IHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfVtdO1xufVxuXG4vKipcbiAqIERlY29tcGlsZSBNb3ZlIGJ5dGVjb2RlIGludG8gcmVhZGFibGUgcHNldWRvLWNvZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcGlsZUJ5dGVjb2RlKGJ5dGVjb2RlOiBzdHJpbmcpOiBEZWNvbXBpbGVkTW9kdWxlIHtcbiAgY29uc3QgbGluZXMgPSBieXRlY29kZS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBleHRyYWN0TW9kdWxlTmFtZShsaW5lcyk7XG4gIGNvbnN0IHN0cnVjdHMgPSBleHRyYWN0U3RydWN0cyhsaW5lcyk7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IGV4dHJhY3RBbmREZWNvbXBpbGVGdW5jdGlvbnMoYnl0ZWNvZGUpO1xuXG4gIHJldHVybiB7XG4gICAgbW9kdWxlTmFtZSxcbiAgICBzdHJ1Y3RzLFxuICAgIGZ1bmN0aW9ucyxcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IG1vZHVsZSBuYW1lIGZyb20gYnl0ZWNvZGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1vZHVsZU5hbWUobGluZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9ebW9kdWxlXFxzK1tcXHcuXStcXC4oXFx3KylcXHMqXFx7Lyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIHJldHVybiAndW5rbm93bic7XG59XG5cbi8qKlxuICogRXh0cmFjdCBzdHJ1Y3QgZGVmaW5pdGlvbnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFN0cnVjdHMobGluZXM6IHN0cmluZ1tdKTogRGVjb21waWxlZFN0cnVjdFtdIHtcbiAgY29uc3Qgc3RydWN0czogRGVjb21waWxlZFN0cnVjdFtdID0gW107XG4gIGxldCBjdXJyZW50U3RydWN0OiBEZWNvbXBpbGVkU3RydWN0IHwgbnVsbCA9IG51bGw7XG4gIGxldCBpblN0cnVjdCA9IGZhbHNlO1xuICBsZXQgYnJhY2VDb3VudCA9IDA7XG5cbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3Qgc3RydWN0TWF0Y2ggPSBsaW5lLm1hdGNoKC9ec3RydWN0XFxzKyhcXHcrKSg/OjxbXj5dKz4pP1xccytoYXNcXHMrKFtcXHcsXFxzXSspXFxzKlxcey8pO1xuICAgIGlmIChzdHJ1Y3RNYXRjaCkge1xuICAgICAgY3VycmVudFN0cnVjdCA9IHtcbiAgICAgICAgbmFtZTogc3RydWN0TWF0Y2hbMV0sXG4gICAgICAgIGFiaWxpdGllczogc3RydWN0TWF0Y2hbMl0uc3BsaXQoJywnKS5tYXAoYSA9PiBhLnRyaW0oKSksXG4gICAgICAgIGZpZWxkczogW10sXG4gICAgICB9O1xuICAgICAgaW5TdHJ1Y3QgPSB0cnVlO1xuICAgICAgYnJhY2VDb3VudCA9IDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBBbHNvIG1hdGNoIHN0cnVjdHMgd2l0aG91dCBhYmlsaXRpZXNcbiAgICBjb25zdCBzdHJ1Y3RNYXRjaE5vQWJpbGl0aWVzID0gbGluZS5tYXRjaCgvXnN0cnVjdFxccysoXFx3KykoPzo8W14+XSs+KT9cXHMqXFx7Lyk7XG4gICAgaWYgKHN0cnVjdE1hdGNoTm9BYmlsaXRpZXMgJiYgIWluU3RydWN0KSB7XG4gICAgICBjdXJyZW50U3RydWN0ID0ge1xuICAgICAgICBuYW1lOiBzdHJ1Y3RNYXRjaE5vQWJpbGl0aWVzWzFdLFxuICAgICAgICBhYmlsaXRpZXM6IFtdLFxuICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgfTtcbiAgICAgIGluU3RydWN0ID0gdHJ1ZTtcbiAgICAgIGJyYWNlQ291bnQgPSAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGluU3RydWN0ICYmIGN1cnJlbnRTdHJ1Y3QpIHtcbiAgICAgIGNvbnN0IGZpZWxkTWF0Y2ggPSBsaW5lLm1hdGNoKC9eXFxzKihcXHcrKTpcXHMqKC4rPyksP1xccyokLyk7XG4gICAgICBpZiAoZmllbGRNYXRjaCkge1xuICAgICAgICBjdXJyZW50U3RydWN0LmZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBmaWVsZE1hdGNoWzFdLFxuICAgICAgICAgIHR5cGU6IGNsZWFuVHlwZShmaWVsZE1hdGNoWzJdKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCd9JykpIHtcbiAgICAgICAgYnJhY2VDb3VudC0tO1xuICAgICAgICBpZiAoYnJhY2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgc3RydWN0cy5wdXNoKGN1cnJlbnRTdHJ1Y3QpO1xuICAgICAgICAgIGN1cnJlbnRTdHJ1Y3QgPSBudWxsO1xuICAgICAgICAgIGluU3RydWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RydWN0cztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGFuZCBkZWNvbXBpbGUgZnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBbmREZWNvbXBpbGVGdW5jdGlvbnMoYnl0ZWNvZGU6IHN0cmluZyk6IERlY29tcGlsZWRGdW5jdGlvbltdIHtcbiAgY29uc3QgZnVuY3Rpb25zOiBEZWNvbXBpbGVkRnVuY3Rpb25bXSA9IFtdO1xuXG4gIC8vIFNwbGl0IGJ5IGZ1bmN0aW9uIHBhdHRlcm5zXG4gIGNvbnN0IGZ1bmNCbG9ja3MgPSBieXRlY29kZS5zcGxpdCgvXFxuKD89KD86cHVibGljfGVudHJ5fGZyaWVuZHxwcml2YXRlKVxccykvKTtcblxuICBmb3IgKGNvbnN0IGJsb2NrIG9mIGZ1bmNCbG9ja3MpIHtcbiAgICBjb25zdCBmdW5jID0gcGFyc2VGdW5jdGlvbihibG9jayk7XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIGZ1bmN0aW9ucy5wdXNoKGZ1bmMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbnM7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgZnVuY3Rpb24gYmxvY2tcbiAqL1xuZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihibG9jazogc3RyaW5nKTogRGVjb21waWxlZEZ1bmN0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IGxpbmVzID0gYmxvY2suc3BsaXQoJ1xcbicpO1xuICBjb25zdCBmaXJzdExpbmUgPSBsaW5lc1swXTtcblxuICAvLyBNYXRjaCBmdW5jdGlvbiBzaWduYXR1cmVcbiAgY29uc3Qgc2lnTWF0Y2ggPSBmaXJzdExpbmUubWF0Y2goL14ocHVibGljKD86XFxzK2VudHJ5KT98ZW50cnl8ZnJpZW5kfHByaXZhdGUpP1xccyooXFx3KykoPzo8KFtePl0rKT4pP1xcKChbXildKilcXCkoPzpcXHMqOlxccyooW15cXHtdKykpPy8pO1xuICBpZiAoIXNpZ01hdGNoKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCB2aXNpYmlsaXR5ID0gc2lnTWF0Y2hbMV0gfHwgJ3ByaXZhdGUnO1xuICBjb25zdCBuYW1lID0gc2lnTWF0Y2hbMl07XG4gIGNvbnN0IHR5cGVQYXJhbXNTdHIgPSBzaWdNYXRjaFszXSB8fCAnJztcbiAgY29uc3QgcGFyYW1zU3RyID0gc2lnTWF0Y2hbNF0gfHwgJyc7XG4gIGNvbnN0IHJldHVyblR5cGUgPSBzaWdNYXRjaFs1XT8udHJpbSgpIHx8ICd2b2lkJztcblxuICAvLyBTa2lwIGlmIGl0IGxvb2tzIGxpa2UgYSBzdHJ1Y3Qgb3IgbW9kdWxlIGRlZmluaXRpb25cbiAgaWYgKFsnbW9kdWxlJywgJ3N0cnVjdCcsICd1c2UnLCAnY29uc3QnXS5pbmNsdWRlcyhuYW1lKSkgcmV0dXJuIG51bGw7XG5cbiAgLy8gUGFyc2UgdHlwZSBwYXJhbWV0ZXJzXG4gIGNvbnN0IHR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zU3RyID8gdHlwZVBhcmFtc1N0ci5zcGxpdCgnLCcpLm1hcCh0ID0+IHQudHJpbSgpKSA6IFtdO1xuXG4gIC8vIFBhcnNlIHBhcmFtZXRlcnNcbiAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbXMocGFyYW1zU3RyKTtcblxuICAvLyBFeHRyYWN0IGFuZCBkZWNvbXBpbGUgYm9keVxuICBjb25zdCBib2R5TGluZXMgPSBsaW5lcy5zbGljZSgxKTtcbiAgY29uc3Qgb3JpZ2luYWxCeXRlY29kZSA9IGJvZHlMaW5lcy5qb2luKCdcXG4nKTtcbiAgY29uc3QgYm9keSA9IGRlY29tcGlsZUZ1bmN0aW9uQm9keShib2R5TGluZXMsIHBhcmFtcywgbmFtZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHZpc2liaWxpdHksXG4gICAgdHlwZVBhcmFtcyxcbiAgICBwYXJhbXMsXG4gICAgcmV0dXJuVHlwZTogY2xlYW5UeXBlKHJldHVyblR5cGUpLFxuICAgIGJvZHksXG4gICAgb3JpZ2luYWxCeXRlY29kZSxcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBmdW5jdGlvbiBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKHBhcmFtc1N0cjogc3RyaW5nKTogeyBuYW1lOiBzdHJpbmc7IHR5cGU6IHN0cmluZyB9W10ge1xuICBpZiAoIXBhcmFtc1N0ci50cmltKCkpIHJldHVybiBbXTtcblxuICBjb25zdCBwYXJhbXM6IHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfVtdID0gW107XG5cbiAgLy8gSGFuZGxlIG5lc3RlZCBnZW5lcmljcyBwcm9wZXJseVxuICBsZXQgZGVwdGggPSAwO1xuICBsZXQgY3VycmVudCA9ICcnO1xuXG4gIGZvciAoY29uc3QgY2hhciBvZiBwYXJhbXNTdHIpIHtcbiAgICBpZiAoY2hhciA9PT0gJzwnKSBkZXB0aCsrO1xuICAgIGlmIChjaGFyID09PSAnPicpIGRlcHRoLS07XG4gICAgaWYgKGNoYXIgPT09ICcsJyAmJiBkZXB0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoKC8oXFx3Kyk6XFxzKiguKykvKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBwYXJhbXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbWF0Y2hbMV0sXG4gICAgICAgICAgdHlwZTogY2xlYW5UeXBlKG1hdGNoWzJdKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgbGFzdCBwYXJhbWV0ZXJcbiAgaWYgKGN1cnJlbnQudHJpbSgpKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoKC8oXFx3Kyk6XFxzKiguKykvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgICAgbmFtZTogbWF0Y2hbMV0sXG4gICAgICAgIHR5cGU6IGNsZWFuVHlwZShtYXRjaFsyXSksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vKipcbiAqIERlY29tcGlsZSBmdW5jdGlvbiBib2R5IGZyb20gYnl0ZWNvZGUgaW5zdHJ1Y3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGRlY29tcGlsZUZ1bmN0aW9uQm9keShcbiAgbGluZXM6IHN0cmluZ1tdLFxuICBwYXJhbXM6IHsgbmFtZTogc3RyaW5nOyB0eXBlOiBzdHJpbmcgfVtdLFxuICBmdW5jTmFtZTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBzdGF0ZW1lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBsb2NhbHM6IE1hcDxzdHJpbmcsIHN0cmluZz4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgbG9jYWxDb3VudGVyID0gMDtcblxuICAvLyBJbml0aWFsaXplIHBhcmFtcyBpbiBsb2NhbHNcbiAgcGFyYW1zLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICBsb2NhbHMuc2V0KGBBcmcke2l9YCwgcC5uYW1lKTtcbiAgfSk7XG5cbiAgLy8gUGFyc2UgbG9jYWwgdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSBsaW5lLm1hdGNoKC9eTChcXGQrKTpcXHMqbG9jXFxkKzpcXHMqKC4rKSQvKTtcbiAgICBpZiAobG9jYWxNYXRjaCkge1xuICAgICAgY29uc3QgdmFyTmFtZSA9IGdlbmVyYXRlVmFyTmFtZShsb2NhbE1hdGNoWzJdLCBsb2NhbENvdW50ZXIrKyk7XG4gICAgICBsb2NhbHMuc2V0KGBMJHtsb2NhbE1hdGNoWzFdfWAsIHZhck5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByb2Nlc3MgYnl0ZWNvZGUgaW5zdHJ1Y3Rpb25zXG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICBpZiAoIXRyaW1tZWQgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCdMJykgfHwgdHJpbW1lZC5zdGFydHNXaXRoKCdCJykpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgaW5zdHJNYXRjaCA9IHRyaW1tZWQubWF0Y2goL15cXGQrOlxccyooXFx3KykoPzpcXFsoW15cXF1dKilcXF0pPyg/OlxcKChbXildKilcXCkpPyQvKTtcbiAgICBpZiAoIWluc3RyTWF0Y2gpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgWywgb3Bjb2RlLCBvcGVyYW5kLCBhbm5vdGF0aW9uXSA9IGluc3RyTWF0Y2g7XG4gICAgcHJvY2Vzc0luc3RydWN0aW9uKG9wY29kZSwgb3BlcmFuZCwgYW5ub3RhdGlvbiwgbG9jYWxzLCBzdGFjaywgc3RhdGVtZW50cyk7XG4gIH1cblxuICAvLyBGb3JtYXQgdGhlIGJvZHlcbiAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcgICAgLy8gQ29tcGxleCBieXRlY29kZSAtIHNlZSBvcmlnaW5hbCBmb3IgZGV0YWlscyc7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50cy5tYXAocyA9PiBgICAgICR7c31gKS5qb2luKCdcXG4nKTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIGEgc2luZ2xlIGJ5dGVjb2RlIGluc3RydWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NJbnN0cnVjdGlvbihcbiAgb3Bjb2RlOiBzdHJpbmcsXG4gIG9wZXJhbmQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgYW5ub3RhdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBsb2NhbHM6IE1hcDxzdHJpbmcsIHN0cmluZz4sXG4gIHN0YWNrOiBzdHJpbmdbXSxcbiAgc3RhdGVtZW50czogc3RyaW5nW11cbik6IHZvaWQge1xuICBzd2l0Y2ggKG9wY29kZSkge1xuICAgIGNhc2UgJ0NvcHlMb2MnOlxuICAgIGNhc2UgJ01vdmVMb2MnOiB7XG4gICAgICBjb25zdCB2YXJOYW1lID0gZ2V0TG9jYWxOYW1lKG9wZXJhbmQsIGFubm90YXRpb24sIGxvY2Fscyk7XG4gICAgICBzdGFjay5wdXNoKHZhck5hbWUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnSW1tQm9ycm93TG9jJzpcbiAgICBjYXNlICdNdXRCb3Jyb3dMb2MnOiB7XG4gICAgICBjb25zdCB2YXJOYW1lID0gZ2V0TG9jYWxOYW1lKG9wZXJhbmQsIGFubm90YXRpb24sIGxvY2Fscyk7XG4gICAgICBjb25zdCBwcmVmaXggPSBvcGNvZGUgPT09ICdNdXRCb3Jyb3dMb2MnID8gJyZtdXQgJyA6ICcmJztcbiAgICAgIHN0YWNrLnB1c2goYCR7cHJlZml4fSR7dmFyTmFtZX1gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1N0TG9jJzoge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBjb25zdCB2YXJOYW1lID0gZ2V0TG9jYWxOYW1lKG9wZXJhbmQsIGFubm90YXRpb24sIGxvY2Fscyk7XG4gICAgICAvLyBBdm9pZCBkdXBsaWNhdGUgbGV0IHN0YXRlbWVudHNcbiAgICAgIGlmICghc3RhdGVtZW50cy5zb21lKHMgPT4gcy5zdGFydHNXaXRoKGBsZXQgJHt2YXJOYW1lfSA9YCkpKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChgbGV0ICR7dmFyTmFtZX0gPSAke3ZhbHVlfTtgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChgJHt2YXJOYW1lfSA9ICR7dmFsdWV9O2ApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnQ2FsbCc6IHtcbiAgICAgIGNvbnN0IGZ1bmNDYWxsID0gcGFyc2VDYWxsQW5ub3RhdGlvbihhbm5vdGF0aW9uKTtcbiAgICAgIGlmIChmdW5jQ2FsbCkge1xuICAgICAgICBjb25zdCB7IG1vZHVsZSwgZnVuYywgcmV0dXJuVHlwZSwgYXJnQ291bnQgfSA9IGZ1bmNDYWxsO1xuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgICAgICAgIGFyZ3MudW5zaGlmdChzdGFjay5wb3AoKSB8fCAnPycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FsbEV4cHIgPSBgJHttb2R1bGV9Ojoke2Z1bmN9KCR7YXJncy5qb2luKCcsICcpfSlgO1xuXG4gICAgICAgIGlmIChyZXR1cm5UeXBlICYmIHJldHVyblR5cGUgIT09ICcoKScpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGNhbGxFeHByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYCR7Y2FsbEV4cHJ9O2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdQYWNrJzoge1xuICAgICAgY29uc3Qgc3RydWN0SW5mbyA9IHBhcnNlUGFja0Fubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICBpZiAoc3RydWN0SW5mbykge1xuICAgICAgICBzdGFjay5wdXNoKGAke3N0cnVjdEluZm8ubmFtZX0geyAuLi4gfWApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnVW5wYWNrJzoge1xuICAgICAgY29uc3Qgc3RydWN0SW5mbyA9IHBhcnNlUGFja0Fubm90YXRpb24oYW5ub3RhdGlvbik7XG4gICAgICBpZiAoc3RydWN0SW5mbykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YWNrLnBvcCgpIHx8ICc/JztcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGBsZXQgJHtzdHJ1Y3RJbmZvLm5hbWV9IHsgLi4uIH0gPSAke3ZhbHVlfTtgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1JldCc6IHtcbiAgICAgIGNvbnN0IHJldHVyblZhbCA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKHJldHVyblZhbCkge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYHJldHVybiAke3JldHVyblZhbH07YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goJ3JldHVybjsnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0ZyZWV6ZVJlZic6IHtcbiAgICAgIGNvbnN0IHZhbCA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKHZhbD8uc3RhcnRzV2l0aCgnJm11dCAnKSkge1xuICAgICAgICBzdGFjay5wdXNoKHZhbC5yZXBsYWNlKCcmbXV0ICcsICcmJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sucHVzaCh2YWwgfHwgJz8nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0xkVTgnOlxuICAgIGNhc2UgJ0xkVTE2JzpcbiAgICBjYXNlICdMZFUzMic6XG4gICAgY2FzZSAnTGRVNjQnOlxuICAgIGNhc2UgJ0xkVTEyOCc6XG4gICAgY2FzZSAnTGRVMjU2Jzoge1xuICAgICAgc3RhY2sucHVzaChvcGVyYW5kIHx8ICcwJyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdMZFRydWUnOlxuICAgICAgc3RhY2sucHVzaCgndHJ1ZScpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdMZEZhbHNlJzpcbiAgICAgIHN0YWNrLnB1c2goJ2ZhbHNlJyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0xkQ29uc3QnOiB7XG4gICAgICBzdGFjay5wdXNoKGFubm90YXRpb24gfHwgJ0NPTlNUJyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdQb3AnOiB7XG4gICAgICBjb25zdCB2YWwgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmICh2YWwgJiYgIXZhbC5zdGFydHNXaXRoKCc/JykpIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKGBfID0gJHt2YWx9O2ApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnQnJUcnVlJzpcbiAgICBjYXNlICdCckZhbHNlJzoge1xuICAgICAgY29uc3QgY29uZCA9IHN0YWNrLnBvcCgpO1xuICAgICAgaWYgKGNvbmQpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZCA9IG9wY29kZSA9PT0gJ0JyVHJ1ZScgPyAnaWYnIDogJ2lmICEnO1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goYCR7a2V5d29yZH0oJHtjb25kfSkgeyAvKiBicmFuY2ggKi8gfWApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnQnJhbmNoJzoge1xuICAgICAgc3RhdGVtZW50cy5wdXNoKCcvLyBqdW1wJyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdBYm9ydCc6IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGF0ZW1lbnRzLnB1c2goYGFib3J0ICR7Y29kZX07YCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdJbW1Cb3Jyb3dGaWVsZCc6XG4gICAgY2FzZSAnTXV0Qm9ycm93RmllbGQnOiB7XG4gICAgICBjb25zdCBvYmogPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBjb25zdCBmaWVsZE5hbWUgPSBhbm5vdGF0aW9uPy5tYXRjaCgvXFwuKFxcdyspLyk/LlsxXSB8fCAnZmllbGQnO1xuICAgICAgY29uc3QgcHJlZml4ID0gb3Bjb2RlID09PSAnTXV0Qm9ycm93RmllbGQnID8gJyZtdXQgJyA6ICcmJztcbiAgICAgIHN0YWNrLnB1c2goYCR7cHJlZml4fSR7b2JqfS4ke2ZpZWxkTmFtZX1gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1JlYWRSZWYnOiB7XG4gICAgICBjb25zdCByZWYgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGFjay5wdXNoKGAqJHtyZWZ9YCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdXcml0ZVJlZic6IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgY29uc3QgcmVmID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgc3RhdGVtZW50cy5wdXNoKGAqJHtyZWZ9ID0gJHt2YWx1ZX07YCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdBZGQnOlxuICAgIGNhc2UgJ1N1Yic6XG4gICAgY2FzZSAnTXVsJzpcbiAgICBjYXNlICdEaXYnOlxuICAgIGNhc2UgJ01vZCc6IHtcbiAgICAgIGNvbnN0IGIgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBjb25zdCBhID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgY29uc3Qgb3AgPSB7IEFkZDogJysnLCBTdWI6ICctJywgTXVsOiAnKicsIERpdjogJy8nLCBNb2Q6ICclJyB9W29wY29kZV07XG4gICAgICBzdGFjay5wdXNoKGAoJHthfSAke29wfSAke2J9KWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTHQnOlxuICAgIGNhc2UgJ0xlJzpcbiAgICBjYXNlICdHdCc6XG4gICAgY2FzZSAnR2UnOlxuICAgIGNhc2UgJ0VxJzpcbiAgICBjYXNlICdOZXEnOiB7XG4gICAgICBjb25zdCBiID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgY29uc3QgYSA9IHN0YWNrLnBvcCgpIHx8ICc/JztcbiAgICAgIGNvbnN0IG9wID0geyBMdDogJzwnLCBMZTogJzw9JywgR3Q6ICc+JywgR2U6ICc+PScsIEVxOiAnPT0nLCBOZXE6ICchPScgfVtvcGNvZGVdO1xuICAgICAgc3RhY2sucHVzaChgKCR7YX0gJHtvcH0gJHtifSlgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ0FuZCc6IHtcbiAgICAgIGNvbnN0IGIgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBjb25zdCBhID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgc3RhY2sucHVzaChgKCR7YX0gJiYgJHtifSlgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ09yJzoge1xuICAgICAgY29uc3QgYiA9IHN0YWNrLnBvcCgpIHx8ICc/JztcbiAgICAgIGNvbnN0IGEgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGFjay5wdXNoKGAoJHthfSB8fCAke2J9KWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnTm90Jzoge1xuICAgICAgY29uc3QgYSA9IHN0YWNrLnBvcCgpIHx8ICc/JztcbiAgICAgIHN0YWNrLnB1c2goYCEke2F9YCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdDYXN0VTgnOlxuICAgIGNhc2UgJ0Nhc3RVMTYnOlxuICAgIGNhc2UgJ0Nhc3RVMzInOlxuICAgIGNhc2UgJ0Nhc3RVNjQnOlxuICAgIGNhc2UgJ0Nhc3RVMTI4JzpcbiAgICBjYXNlICdDYXN0VTI1Nic6IHtcbiAgICAgIGNvbnN0IHZhbCA9IHN0YWNrLnBvcCgpIHx8ICc/JztcbiAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSBvcGNvZGUucmVwbGFjZSgnQ2FzdCcsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3RhY2sucHVzaChgKCR7dmFsfSBhcyAke3RhcmdldFR5cGV9KWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnVmVjUGFjayc6IHtcbiAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQob3BlcmFuZCB8fCAnMCcsIDEwKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgZWxlbWVudHMudW5zaGlmdChzdGFjay5wb3AoKSB8fCAnPycpO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaChgdmVjdG9yWyR7ZWxlbWVudHMuam9pbignLCAnKX1dYCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjYXNlICdWZWNMZW4nOiB7XG4gICAgICBjb25zdCB2ZWMgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGFjay5wdXNoKGAke3ZlY30ubGVuZ3RoKClgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1ZlY0ltbUJvcnJvdyc6XG4gICAgY2FzZSAnVmVjTXV0Qm9ycm93Jzoge1xuICAgICAgY29uc3QgaWR4ID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgY29uc3QgdmVjID0gc3RhY2sucG9wKCkgfHwgJz8nO1xuICAgICAgY29uc3QgcHJlZml4ID0gb3Bjb2RlID09PSAnVmVjTXV0Qm9ycm93JyA/ICcmbXV0ICcgOiAnJic7XG4gICAgICBzdGFjay5wdXNoKGAke3ByZWZpeH0ke3ZlY31bJHtpZHh9XWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnVmVjUHVzaEJhY2snOiB7XG4gICAgICBjb25zdCB2YWwgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBjb25zdCB2ZWMgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGF0ZW1lbnRzLnB1c2goYCR7dmVjfS5wdXNoX2JhY2soJHt2YWx9KTtgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ1ZlY1BvcEJhY2snOiB7XG4gICAgICBjb25zdCB2ZWMgPSBzdGFjay5wb3AoKSB8fCAnPyc7XG4gICAgICBzdGFjay5wdXNoKGAke3ZlY30ucG9wX2JhY2soKWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFVua25vd24gb3Bjb2RlIC0gc2tpcCBzaWxlbnRseSB0byBhdm9pZCBub2lzZVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgbG9jYWwgdmFyaWFibGUgbmFtZVxuICovXG5mdW5jdGlvbiBnZXRMb2NhbE5hbWUoXG4gIG9wZXJhbmQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgYW5ub3RhdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBsb2NhbHM6IE1hcDxzdHJpbmcsIHN0cmluZz5cbik6IHN0cmluZyB7XG4gIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgLy8gVHJ5IHRvIGV4dHJhY3QgZnJvbSBhbm5vdGF0aW9uIGxpa2UgXCJBcmcwOiAmbXV0IFR4Q29udGV4dFwiXG4gICAgY29uc3QgbWF0Y2ggPSBhbm5vdGF0aW9uLm1hdGNoKC9eKFxcdyspOi8pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV07XG4gICAgICBpZiAobG9jYWxzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBsb2NhbHMuZ2V0KGtleSkhO1xuICAgICAgfVxuICAgICAgLy8gSXQncyBhIG5ldyB2YXJpYWJsZSBuYW1lIGZyb20gYW5ub3RhdGlvblxuICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBpZiAob3BlcmFuZCkge1xuICAgIHJldHVybiBsb2NhbHMuZ2V0KG9wZXJhbmQpIHx8IG9wZXJhbmQudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gJ3Zhcic7XG59XG5cbi8qKlxuICogUGFyc2UgQ2FsbCBhbm5vdGF0aW9uIHRvIGV4dHJhY3QgZnVuY3Rpb24gaW5mb1xuICovXG5mdW5jdGlvbiBwYXJzZUNhbGxBbm5vdGF0aW9uKGFubm90YXRpb246IHN0cmluZyB8IHVuZGVmaW5lZCk6IHtcbiAgbW9kdWxlOiBzdHJpbmc7XG4gIGZ1bmM6IHN0cmluZztcbiAgcmV0dXJuVHlwZTogc3RyaW5nO1xuICBhcmdDb3VudDogbnVtYmVyO1xufSB8IG51bGwge1xuICBpZiAoIWFubm90YXRpb24pIHJldHVybiBudWxsO1xuXG4gIC8vIFBhdHRlcm46IG1vZHVsZTo6ZnVuYzxUeXBlQXJncz4oQXJnVHlwZXMpOiBSZXR1cm5UeXBlXG4gIGNvbnN0IG1hdGNoID0gYW5ub3RhdGlvbi5tYXRjaCgvKFxcdyspOjooXFx3KykoPzo8W14+XSs+KT9cXCgoW14pXSopXFwpKD86OlxccyooLispKT8vKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgYXJnVHlwZXMgPSBtYXRjaFszXSA/IG1hdGNoWzNdLnNwbGl0KCcsJykuZmlsdGVyKGEgPT4gYS50cmltKCkpIDogW107XG5cbiAgcmV0dXJuIHtcbiAgICBtb2R1bGU6IG1hdGNoWzFdLFxuICAgIGZ1bmM6IG1hdGNoWzJdLFxuICAgIHJldHVyblR5cGU6IG1hdGNoWzRdPy50cmltKCkgfHwgJycsXG4gICAgYXJnQ291bnQ6IGFyZ1R5cGVzLmxlbmd0aCxcbiAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBQYWNrIGFubm90YXRpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYWNrQW5ub3RhdGlvbihhbm5vdGF0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB7IG5hbWU6IHN0cmluZyB9IHwgbnVsbCB7XG4gIGlmICghYW5ub3RhdGlvbikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG1hdGNoID0gYW5ub3RhdGlvbi5tYXRjaCgvKFxcdyspKD86PHwkKS8pO1xuICByZXR1cm4gbWF0Y2ggPyB7IG5hbWU6IG1hdGNoWzFdIH0gOiBudWxsO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHZhcmlhYmxlIG5hbWUgZnJvbSB0eXBlIHdpdGggZW5oYW5jZWQgaW5mZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVmFyTmFtZSh0eXBlOiBzdHJpbmcsIGluZGV4OiBudW1iZXIsIGNvbnRleHQ/OiB7IGZ1bmNOYW1lPzogc3RyaW5nOyBwYXJhbUluZGV4PzogbnVtYmVyIH0pOiBzdHJpbmcge1xuICBjb25zdCBjbGVhbmVkVHlwZSA9IHR5cGUucmVwbGFjZSgvPC4qPi8sICcnKS50cmltKCk7XG4gIGNvbnN0IHBhcnRzID0gY2xlYW5lZFR5cGUuc3BsaXQoJzo6Jyk7XG4gIGNvbnN0IHR5cGVOYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cbiAgLy8gRXh0cmFjdCBnZW5lcmljIHR5cGUgcGFyYW1ldGVyIGlmIHByZXNlbnRcbiAgY29uc3QgZ2VuZXJpY01hdGNoID0gdHlwZS5tYXRjaCgvPChbXjw+XSspPi8pO1xuICBjb25zdCBnZW5lcmljVHlwZSA9IGdlbmVyaWNNYXRjaCA/IGdlbmVyaWNNYXRjaFsxXS5zcGxpdCgnOjonKS5wb3AoKSA6IG51bGw7XG5cbiAgLy8gRW5oYW5jZWQgbmFtZSBtYXBwaW5nIHdpdGggc2VtYW50aWMgY29udGV4dFxuICBjb25zdCBuYW1lTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgIC8vIE9iamVjdCB0eXBlc1xuICAgICdVSUQnOiAndWlkJyxcbiAgICAnSUQnOiAnaWQnLFxuICAgICdCYWcnOiAnYmFnJyxcbiAgICAnVGFibGUnOiAndGFibGUnLFxuICAgICdWZWNTZXQnOiAndmVjX3NldCcsXG4gICAgJ1ZlY01hcCc6ICd2ZWNfbWFwJyxcbiAgICAnT2JqZWN0QmFnJzogJ29iamVjdF9iYWcnLFxuICAgICdPYmplY3RUYWJsZSc6ICdvYmplY3RfdGFibGUnLFxuICAgICdMaW5rZWRUYWJsZSc6ICdsaW5rZWRfdGFibGUnLFxuXG4gICAgLy8gVG9rZW4gdHlwZXNcbiAgICAnQ29pbic6IGdlbmVyaWNUeXBlID8gYCR7Z2VuZXJpY1R5cGUudG9Mb3dlckNhc2UoKX1fY29pbmAgOiAnY29pbicsXG4gICAgJ0JhbGFuY2UnOiBnZW5lcmljVHlwZSA/IGAke2dlbmVyaWNUeXBlLnRvTG93ZXJDYXNlKCl9X2JhbGFuY2VgIDogJ2JhbGFuY2UnLFxuICAgICdUcmVhc3VyeUNhcCc6ICd0cmVhc3VyeV9jYXAnLFxuICAgICdDb2luTWV0YWRhdGEnOiAnY29pbl9tZXRhZGF0YScsXG4gICAgJ1N1cHBseSc6ICdzdXBwbHknLFxuXG4gICAgLy8gQ29tbW9uIHR5cGVzXG4gICAgJ1R4Q29udGV4dCc6ICdjdHgnLFxuICAgICdhZGRyZXNzJzogJ3JlY2lwaWVudCcsXG4gICAgJ3U2NCc6ICdhbW91bnQnLFxuICAgICd1MTI4JzogJ3ZhbHVlJyxcbiAgICAndTI1Nic6ICdiaWdfdmFsdWUnLFxuICAgICd1OCc6ICdieXRlX3ZhbCcsXG4gICAgJ3UxNic6ICdzaG9ydF92YWwnLFxuICAgICd1MzInOiAnaW50X3ZhbCcsXG4gICAgJ2Jvb2wnOiAnaXNfdmFsaWQnLFxuICAgICdTdHJpbmcnOiAnbmFtZScsXG4gICAgJ1VybCc6ICd1cmwnLFxuICAgICdPcHRpb24nOiBnZW5lcmljVHlwZSA/IGBtYXliZV8ke2dlbmVyaWNUeXBlLnRvTG93ZXJDYXNlKCl9YCA6ICdvcHRpb24nLFxuXG4gICAgLy8gVmVjdG9yIHR5cGVzXG4gICAgJ3ZlY3Rvcic6IGdlbmVyaWNUeXBlID8gYCR7Z2VuZXJpY1R5cGUudG9Mb3dlckNhc2UoKX1fbGlzdGAgOiAnaXRlbXMnLFxuXG4gICAgLy8gQ2FwYWJpbGl0eSB0eXBlc1xuICAgICdBZG1pbkNhcCc6ICdhZG1pbl9jYXAnLFxuICAgICdPd25lckNhcCc6ICdvd25lcl9jYXAnLFxuICAgICdVcGdyYWRlQ2FwJzogJ3VwZ3JhZGVfY2FwJyxcbiAgICAnUHVibGlzaGVyJzogJ3B1Ymxpc2hlcicsXG5cbiAgICAvLyBDbG9jayAmIHRpbWVcbiAgICAnQ2xvY2snOiAnY2xvY2snLFxuXG4gICAgLy8gRGVGaSBjb21tb24gdHlwZXNcbiAgICAnUG9vbCc6ICdwb29sJyxcbiAgICAnUG9zaXRpb24nOiAncG9zaXRpb24nLFxuICAgICdMaXF1aWRpdHknOiAnbGlxdWlkaXR5JyxcbiAgICAnT3JhY2xlJzogJ29yYWNsZScsXG4gICAgJ1ByaWNlSW5mbyc6ICdwcmljZV9pbmZvJyxcbiAgfTtcblxuICAvLyBDb250ZXh0LWF3YXJlIG5hbWluZyBiYXNlZCBvbiBmdW5jdGlvbiBuYW1lXG4gIGlmIChjb250ZXh0Py5mdW5jTmFtZSkge1xuICAgIGNvbnN0IGZ1bmNMb3dlciA9IGNvbnRleHQuZnVuY05hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIFRyYW5zZmVyIGZ1bmN0aW9uc1xuICAgIGlmIChmdW5jTG93ZXIuaW5jbHVkZXMoJ3RyYW5zZmVyJykgJiYgdHlwZU5hbWUgPT09ICdhZGRyZXNzJykge1xuICAgICAgcmV0dXJuIGluZGV4ID4gMCA/IGByZWNpcGllbnRfJHtpbmRleH1gIDogJ3JlY2lwaWVudCc7XG4gICAgfVxuXG4gICAgLy8gRGVwb3NpdC93aXRoZHJhdyBmdW5jdGlvbnNcbiAgICBpZiAoZnVuY0xvd2VyLmluY2x1ZGVzKCdkZXBvc2l0JykgfHwgZnVuY0xvd2VyLmluY2x1ZGVzKCd3aXRoZHJhdycpKSB7XG4gICAgICBpZiAodHlwZU5hbWUgPT09ICd1NjQnKSByZXR1cm4gaW5kZXggPiAwID8gYGFtb3VudF8ke2luZGV4fWAgOiAnYW1vdW50JztcbiAgICAgIGlmICh0eXBlTmFtZSA9PT0gJ0NvaW4nKSByZXR1cm4gaW5kZXggPiAwID8gYGRlcG9zaXRfY29pbl8ke2luZGV4fWAgOiAnZGVwb3NpdF9jb2luJztcbiAgICB9XG5cbiAgICAvLyBTd2FwIGZ1bmN0aW9uc1xuICAgIGlmIChmdW5jTG93ZXIuaW5jbHVkZXMoJ3N3YXAnKSkge1xuICAgICAgaWYgKGNvbnRleHQucGFyYW1JbmRleCA9PT0gMCAmJiB0eXBlTmFtZSA9PT0gJ0NvaW4nKSByZXR1cm4gJ2NvaW5faW4nO1xuICAgICAgaWYgKGNvbnRleHQucGFyYW1JbmRleCA9PT0gMSAmJiB0eXBlTmFtZSA9PT0gJ0NvaW4nKSByZXR1cm4gJ2NvaW5fb3V0JztcbiAgICAgIGlmICh0eXBlTmFtZSA9PT0gJ3U2NCcpIHJldHVybiBpbmRleCA+IDAgPyBgbWluX291dF8ke2luZGV4fWAgOiAnbWluX2Ftb3VudF9vdXQnO1xuICAgIH1cblxuICAgIC8vIE1pbnQgZnVuY3Rpb25zXG4gICAgaWYgKGZ1bmNMb3dlci5pbmNsdWRlcygnbWludCcpKSB7XG4gICAgICBpZiAodHlwZU5hbWUgPT09ICd1NjQnKSByZXR1cm4gJ21pbnRfYW1vdW50JztcbiAgICAgIGlmICh0eXBlTmFtZSA9PT0gJ1RyZWFzdXJ5Q2FwJykgcmV0dXJuICd0cmVhc3VyeSc7XG4gICAgfVxuXG4gICAgLy8gQnVybiBmdW5jdGlvbnNcbiAgICBpZiAoZnVuY0xvd2VyLmluY2x1ZGVzKCdidXJuJykpIHtcbiAgICAgIGlmICh0eXBlTmFtZSA9PT0gJ0NvaW4nKSByZXR1cm4gJ2J1cm5fY29pbic7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYmFzZU5hbWUgPSBuYW1lTWFwW3R5cGVOYW1lXSB8fCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyhbQS1aXSkvZywgJ18kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXl8vLCAnJyk7XG4gIHJldHVybiBpbmRleCA+IDAgPyBgJHtiYXNlTmFtZX1fJHtpbmRleH1gIDogYmFzZU5hbWU7XG59XG5cbi8qKlxuICogQ2xlYW4gdHlwZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gY2xlYW5UeXBlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlXG4gICAgLnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgIC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbiAgICAucmVwbGFjZSgvLFxccyovZywgJywgJylcbiAgICAucmVwbGFjZSgvLFxccyokLywgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZGVjb21waWxlZCBtb2R1bGUgdG8gTW92ZSBzb3VyY2UgY29kZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTW92ZVNvdXJjZShtb2R1bGU6IERlY29tcGlsZWRNb2R1bGUpOiBzdHJpbmcge1xuICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblxuICBsaW5lcy5wdXNoKGAvLyBEZWNvbXBpbGVkIE1vdmUgbW9kdWxlOiAke21vZHVsZS5tb2R1bGVOYW1lfWApO1xuICBsaW5lcy5wdXNoKGAvLyBOb3RlOiBWYXJpYWJsZSBuYW1lcyBhbmQgY29tbWVudHMgYXJlIGFwcHJveGltYXRlZGApO1xuICBsaW5lcy5wdXNoKCcnKTtcbiAgbGluZXMucHVzaChgbW9kdWxlICR7bW9kdWxlLm1vZHVsZU5hbWV9IHtgKTtcbiAgbGluZXMucHVzaCgnJyk7XG5cbiAgLy8gU3RydWN0c1xuICBmb3IgKGNvbnN0IHN0cnVjdCBvZiBtb2R1bGUuc3RydWN0cykge1xuICAgIGNvbnN0IGFiaWxpdGllcyA9IHN0cnVjdC5hYmlsaXRpZXMubGVuZ3RoID4gMFxuICAgICAgPyBgIGhhcyAke3N0cnVjdC5hYmlsaXRpZXMuam9pbignLCAnKX1gXG4gICAgICA6ICcnO1xuICAgIGxpbmVzLnB1c2goYCAgICBzdHJ1Y3QgJHtzdHJ1Y3QubmFtZX0ke2FiaWxpdGllc30ge2ApO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2Ygc3RydWN0LmZpZWxkcykge1xuICAgICAgbGluZXMucHVzaChgICAgICAgICAke2ZpZWxkLm5hbWV9OiAke2ZpZWxkLnR5cGV9LGApO1xuICAgIH1cbiAgICBsaW5lcy5wdXNoKCcgICAgfScpO1xuICAgIGxpbmVzLnB1c2goJycpO1xuICB9XG5cbiAgLy8gRnVuY3Rpb25zXG4gIGZvciAoY29uc3QgZnVuYyBvZiBtb2R1bGUuZnVuY3Rpb25zKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtcyA9IGZ1bmMudHlwZVBhcmFtcy5sZW5ndGggPiAwXG4gICAgICA/IGA8JHtmdW5jLnR5cGVQYXJhbXMuam9pbignLCAnKX0+YFxuICAgICAgOiAnJztcbiAgICBjb25zdCBwYXJhbXMgPSBmdW5jLnBhcmFtcy5tYXAocCA9PiBgJHtwLm5hbWV9OiAke3AudHlwZX1gKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IHJldHVyblR5cGUgPSBmdW5jLnJldHVyblR5cGUgIT09ICd2b2lkJyA/IGA6ICR7ZnVuYy5yZXR1cm5UeXBlfWAgOiAnJztcblxuICAgIGxpbmVzLnB1c2goYCAgICAke2Z1bmMudmlzaWJpbGl0eX0gZnVuICR7ZnVuYy5uYW1lfSR7dHlwZVBhcmFtc30oJHtwYXJhbXN9KSR7cmV0dXJuVHlwZX0ge2ApO1xuICAgIGxpbmVzLnB1c2goZnVuYy5ib2R5IHx8ICcgICAgICAgIC8vIC4uLicpO1xuICAgIGxpbmVzLnB1c2goJyAgICB9Jyk7XG4gICAgbGluZXMucHVzaCgnJyk7XG4gIH1cblxuICBsaW5lcy5wdXNoKCd9Jyk7XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIFF1aWNrIGRlY29tcGlsZSBmdW5jdGlvbiAtIG1haW4gZW50cnkgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29tcGlsZVRvTW92ZShieXRlY29kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtb2R1bGUgPSBkZWNvbXBpbGVCeXRlY29kZShieXRlY29kZSk7XG4gICAgcmV0dXJuIHRvTW92ZVNvdXJjZShtb2R1bGUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElmIGRlY29tcGlsYXRpb24gZmFpbHMsIHJldHVybiBhbm5vdGF0ZWQgYnl0ZWNvZGVcbiAgICByZXR1cm4gYW5ub3RhdGVCeXRlQ29kZShieXRlY29kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbm5vdGF0ZSBieXRlY29kZSB3aXRoIGNvbW1lbnRzIGZvciBiZXR0ZXIgcmVhZGFiaWxpdHlcbiAqL1xuZnVuY3Rpb24gYW5ub3RhdGVCeXRlQ29kZShieXRlY29kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgYW5ub3RhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgJ0NvcHlMb2MnOiAnLy8gQ29weSBsb2NhbCB2YXJpYWJsZScsXG4gICAgJ01vdmVMb2MnOiAnLy8gTW92ZSBsb2NhbCB2YXJpYWJsZSAoY29uc3VtZSknLFxuICAgICdTdExvYyc6ICcvLyBTdG9yZSB0byBsb2NhbCB2YXJpYWJsZScsXG4gICAgJ0ltbUJvcnJvd0xvYyc6ICcvLyBJbW11dGFibGUgYm9ycm93ICgmKScsXG4gICAgJ011dEJvcnJvd0xvYyc6ICcvLyBNdXRhYmxlIGJvcnJvdyAoJm11dCknLFxuICAgICdJbW1Cb3Jyb3dGaWVsZCc6ICcvLyBCb3Jyb3cgc3RydWN0IGZpZWxkICgmKScsXG4gICAgJ011dEJvcnJvd0ZpZWxkJzogJy8vIEJvcnJvdyBzdHJ1Y3QgZmllbGQgKCZtdXQpJyxcbiAgICAnQ2FsbCc6ICcvLyBGdW5jdGlvbiBjYWxsJyxcbiAgICAnUGFjayc6ICcvLyBDcmVhdGUgc3RydWN0IGluc3RhbmNlJyxcbiAgICAnVW5wYWNrJzogJy8vIERlc3RydWN0dXJlIHN0cnVjdCcsXG4gICAgJ1JldCc6ICcvLyBSZXR1cm4gZnJvbSBmdW5jdGlvbicsXG4gICAgJ0JyVHJ1ZSc6ICcvLyBCcmFuY2ggaWYgdHJ1ZScsXG4gICAgJ0JyRmFsc2UnOiAnLy8gQnJhbmNoIGlmIGZhbHNlJyxcbiAgICAnQnJhbmNoJzogJy8vIFVuY29uZGl0aW9uYWwganVtcCcsXG4gICAgJ0ZyZWV6ZVJlZic6ICcvLyBDb252ZXJ0ICZtdXQgdG8gJicsXG4gICAgJ0xkVTY0JzogJy8vIExvYWQgdTY0IGNvbnN0YW50JyxcbiAgICAnTGRUcnVlJzogJy8vIExvYWQgdHJ1ZScsXG4gICAgJ0xkRmFsc2UnOiAnLy8gTG9hZCBmYWxzZScsXG4gICAgJ1BvcCc6ICcvLyBEaXNjYXJkIHRvcCBvZiBzdGFjaycsXG4gICAgJ0Fib3J0JzogJy8vIEFib3J0IGV4ZWN1dGlvbicsXG4gIH07XG5cbiAgY29uc3QgbGluZXMgPSBieXRlY29kZS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGFubm90YXRlZDogc3RyaW5nW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBhbm5vdGF0ZWQucHVzaChsaW5lKTtcblxuICAgIC8vIEFkZCBhbm5vdGF0aW9uIGZvciBpbnN0cnVjdGlvbiBsaW5lc1xuICAgIGNvbnN0IGluc3RyTWF0Y2ggPSBsaW5lLm1hdGNoKC9eXFxzKlxcZCs6XFxzKihcXHcrKS8pO1xuICAgIGlmIChpbnN0ck1hdGNoICYmIGFubm90YXRpb25zW2luc3RyTWF0Y2hbMV1dKSB7XG4gICAgICBhbm5vdGF0ZWQucHVzaChgICAgICAgICAke2Fubm90YXRpb25zW2luc3RyTWF0Y2hbMV1dfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbm5vdGF0ZWQuam9pbignXFxuJyk7XG59XG4iXSwibmFtZXMiOlsiZGVjb21waWxlQnl0ZWNvZGUiLCJieXRlY29kZSIsImxpbmVzIiwic3BsaXQiLCJtb2R1bGVOYW1lIiwiZXh0cmFjdE1vZHVsZU5hbWUiLCJzdHJ1Y3RzIiwiZXh0cmFjdFN0cnVjdHMiLCJmdW5jdGlvbnMiLCJleHRyYWN0QW5kRGVjb21waWxlRnVuY3Rpb25zIiwibGluZSIsIm1hdGNoIiwiY3VycmVudFN0cnVjdCIsImluU3RydWN0IiwiYnJhY2VDb3VudCIsInN0cnVjdE1hdGNoIiwibmFtZSIsImFiaWxpdGllcyIsIm1hcCIsImEiLCJ0cmltIiwiZmllbGRzIiwic3RydWN0TWF0Y2hOb0FiaWxpdGllcyIsImZpZWxkTWF0Y2giLCJwdXNoIiwidHlwZSIsImNsZWFuVHlwZSIsImluY2x1ZGVzIiwiZnVuY0Jsb2NrcyIsImJsb2NrIiwiZnVuYyIsInBhcnNlRnVuY3Rpb24iLCJmaXJzdExpbmUiLCJzaWdNYXRjaCIsInZpc2liaWxpdHkiLCJ0eXBlUGFyYW1zU3RyIiwicGFyYW1zU3RyIiwicmV0dXJuVHlwZSIsInR5cGVQYXJhbXMiLCJ0IiwicGFyYW1zIiwicGFyc2VQYXJhbXMiLCJib2R5TGluZXMiLCJzbGljZSIsIm9yaWdpbmFsQnl0ZWNvZGUiLCJqb2luIiwiYm9keSIsImRlY29tcGlsZUZ1bmN0aW9uQm9keSIsImRlcHRoIiwiY3VycmVudCIsImNoYXIiLCJmdW5jTmFtZSIsInN0YXRlbWVudHMiLCJsb2NhbHMiLCJNYXAiLCJzdGFjayIsImxvY2FsQ291bnRlciIsImZvckVhY2giLCJwIiwiaSIsInNldCIsImxvY2FsTWF0Y2giLCJ2YXJOYW1lIiwiZ2VuZXJhdGVWYXJOYW1lIiwidHJpbW1lZCIsInN0YXJ0c1dpdGgiLCJpbnN0ck1hdGNoIiwib3Bjb2RlIiwib3BlcmFuZCIsImFubm90YXRpb24iLCJwcm9jZXNzSW5zdHJ1Y3Rpb24iLCJsZW5ndGgiLCJzIiwiZ2V0TG9jYWxOYW1lIiwicHJlZml4IiwidmFsdWUiLCJwb3AiLCJzb21lIiwiZnVuY0NhbGwiLCJwYXJzZUNhbGxBbm5vdGF0aW9uIiwibW9kdWxlIiwiYXJnQ291bnQiLCJhcmdzIiwidW5zaGlmdCIsImNhbGxFeHByIiwic3RydWN0SW5mbyIsInBhcnNlUGFja0Fubm90YXRpb24iLCJyZXR1cm5WYWwiLCJ2YWwiLCJyZXBsYWNlIiwiY29uZCIsImtleXdvcmQiLCJjb2RlIiwib2JqIiwiZmllbGROYW1lIiwicmVmIiwiYiIsIm9wIiwiQWRkIiwiU3ViIiwiTXVsIiwiRGl2IiwiTW9kIiwiTHQiLCJMZSIsIkd0IiwiR2UiLCJFcSIsIk5lcSIsInRhcmdldFR5cGUiLCJ0b0xvd2VyQ2FzZSIsImNvdW50IiwicGFyc2VJbnQiLCJlbGVtZW50cyIsInZlYyIsImlkeCIsImtleSIsImhhcyIsImdldCIsImFyZ1R5cGVzIiwiZmlsdGVyIiwiaW5kZXgiLCJjb250ZXh0IiwiY2xlYW5lZFR5cGUiLCJwYXJ0cyIsInR5cGVOYW1lIiwiZ2VuZXJpY01hdGNoIiwiZ2VuZXJpY1R5cGUiLCJuYW1lTWFwIiwiZnVuY0xvd2VyIiwicGFyYW1JbmRleCIsImJhc2VOYW1lIiwidG9Nb3ZlU291cmNlIiwic3RydWN0IiwiZmllbGQiLCJkZWNvbXBpbGVUb01vdmUiLCJlcnJvciIsImFubm90YXRlQnl0ZUNvZGUiLCJhbm5vdGF0aW9ucyIsImFubm90YXRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/decompiler.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1"], () => (__webpack_exec__("(rsc)/./node_modules/.pnpm/next@14.2.35_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fsource%2Fdecompile%2Froute&page=%2Fapi%2Fsource%2Fdecompile%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsource%2Fdecompile%2Froute.ts&appDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fbond%2Fgithub%2Fbond%2Fauto-sui-skill%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();